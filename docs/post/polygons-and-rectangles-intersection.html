<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Polysec is a framework-agnostic Lua library for detecting intersections and collisions between polygons and rectangles. It provides an efficient algorithm for polygonal intersection detection, making it suitable for the collision handling. While Polysec is independent of any specific framework, examples demonstrating its usage are provided using the Löve2D game development engine. " name=description><meta content="lua, programming, algorithms, data-structures, gamedev, game development, blog, personal" name=keywords><meta content="Dmitri Smirnov" name=author><meta content=website property=og:type><meta content=https://www.whoop.ee/post/polygons-and-rectangles-intersection.html property=og:url><meta content=https://www.whoop.ee/assets/img/whoopee-logo.png property=og:image><meta content="script-src 'self'" http-equiv=Content-Security-Policy><meta content="object-src 'none'" http-equiv=Content-Security-Policy><title>Polygons and rectangles intersection — Whoopee</title><link as=font href=/assets/fonts/Perfect_DOS_VGA_437.woff2 rel=preload><link href=/favicon.ico rel=icon type=image/x-icon><link href=/assets/css/styles.min.css rel=stylesheet><link title="RSS Feed" href=/feed.xml rel=alternate type=application/rss+xml><link href=https://www.whoop.ee/post/polygons-and-rectangles-intersection.html rel=canonical><body><header><a href=/><img alt=Whoopee class=logo height=172 src=/assets/img/whoopee-logo.png width=200></a><nav class=mainmenu><a href=/me/>About</a><a href=/feed.xml>RSS</a></nav></header><main><a href=/>← Back to the index page</a><article><h1>Polygons and rectangles intersection</h1><time datetime=2025-03-19> March 19, 2025 </time><div><input class=toc-toggle id=toc-toggle type=checkbox><label for=toc-toggle>Table of contents</label></div><div class=toc><ul><li><a href=#polygons-and-rectangles-intersection>Polygons and rectangles intersection</a><ul><li><a href=#polysec-library>Polysec library</a><li><a href=#features>Features</a><li><a href=#weiler-athethon-algorithm-shortly>Weiler-Athethon algorithm shortly</a><ul><li><a href=#algorithm-preconditions>Algorithm Preconditions</a><li><a href=#algorithm-steps>Algorithm Steps</a><li><a href=#handling-no-intersection-cases>Handling no intersection cases</a></ul><li><a href=#usage>Usage</a><li><a href=#running-demos>Running demos</a><li><a href=#tests>Tests</a><li><a href=#api>API</a><ul><li><a href=#types>Types</a><li><a href=#modules>Modules</a><ul><li><a href=#point>point</a><li><a href=#rectangle>rectangle</a><li><a href=#polygon>polygon</a><li><a href=#constant>constant</a></ul></ul><li><a href=#references>References</a></ul></ul></div><p>Detecting polygon intersections is a common task in game development and interactive computer graphics. In this post, I describe a polygon intersection algorithm, including how to determine whether a point lies inside a polygon. The examples are implemented using the popular game development engine <a href=https://love2d.org/>Löve2D</a>.<h2 id=polysec-library>Polysec library<a title="Permanent link" class=headerlink href=#polysec-library>#</a></h2><p><img alt="Polysec Logo" src=https://www.whoop.ee/assets/img/polysec.svg><p><a href=https://github.com/dknight/polysec><em>Polysec</em></a> is a framework-agnostic Lua library for detecting intersections and collisions between polygons and rectangles. It provides an efficient algorithm for polygonal intersection detection, making it suitable for the collision handling. While Polysec is independent of any specific framework, it is framework-agnostic.<h2 id=features>Features<a title="Permanent link" class=headerlink href=#features>#</a></h2><ul><li>Detect point belongs to polygon or rectangle.<li>Detect collision of rectangles.<li>Detect collision of polygons.<li>Measure distance between who points.</ul><p><img alt="Polygon intersection animated demonstration in GIF format" src=https://www.whoop.ee/assets/img/polysec-demo.gif><p><a href=https://github.com/dknight/polysec>Download the source code</a> from GitHub.<h2 id=weiler-athethon-algorithm-shortly>Weiler-Athethon algorithm shortly<a title="Permanent link" class=headerlink href=#weiler-athethon-algorithm-shortly>#</a></h2><p>Under the hood <em>Polysec</em> uses the <a href=https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm>Weiler-Athethon algorithm</a> to detect polygon intersections.<h3 id=algorithm-preconditions>Algorithm Preconditions<a title="Permanent link" class=headerlink href=#algorithm-preconditions>#</a></h3><p>Before applying the algorithm to a polygon, the following conditions must be met:<ul><li>Polygons must be oriented in a clockwise direction.<li>Polygons must not be self-intersected (i.e., they should not be re-entrant).</ul><h3 id=algorithm-steps>Algorithm Steps<a title="Permanent link" class=headerlink href=#algorithm-steps>#</a></h3><p>Given polygon A (clipping region) and polygon B (subject region) to be clipped, the algorithm proceeds as follows:<ol><li>List the vertices of both polygon A and polygon B.<li>Classify each vertex of polygon B as either inside or outside of polygon A.<li>Identify all intersection points between the polygons and insert them into both vertex lists, ensuring they are at the intersection points.<li>Determine “inbound” intersections, where the vector from an intersection to the next vertex of polygon B originates inside the clipping region A.<li>Traverse the lists, following each intersection in a clockwise direction until returning to the starting position.</ol><h3 id=handling-no-intersection-cases>Handling no intersection cases<a title="Permanent link" class=headerlink href=#handling-no-intersection-cases>#</a></h3><p>If no intersections are found, one of the following must be true:<ul><li>Polygon A is entirely inside Polygon B.<li>Polygon B is entirely inside Polygon A.<li>Polygons A and B do not overlap.</ul><p><img alt="Illustration of the Weiler-Athethon algorithm" src=https://www.whoop.ee/assets/img/weiler-Athethon-algorithm-01.svg><h2 id=usage>Usage<a title="Permanent link" class=headerlink href=#usage>#</a></h2><div class=codehilite><pre><span></span><code><span class=kd>local</span> <span class=n>polysec</span> <span class=o>=</span> <span class=nb>require</span><span class=p>(</span><span class=s2>"init"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>polygon</span> <span class=o>=</span> <span class=n>polysec</span><span class=p>.</span><span class=n>polygon</span>
<span class=kd>local</span> <span class=n>point</span> <span class=o>=</span> <span class=n>polysec</span><span class=p>.</span><span class=n>point</span>

<span class=kd>local</span> <span class=n>square</span> <span class=o>=</span> <span class=n>polygon</span><span class=p>.</span><span class=n>new</span><span class=p>(</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>150</span><span class=p>),</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=mi>150</span><span class=p>),</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=mi>250</span><span class=p>),</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>250</span><span class=p>)</span>
<span class=p>)</span>
<span class=kd>local</span> <span class=n>triangle</span> <span class=o>=</span> <span class=n>polygon</span><span class=p>.</span><span class=n>new</span><span class=p>(</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>125</span><span class=p>,</span> <span class=mi>125</span><span class=p>),</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mf>62.5</span><span class=p>,</span> <span class=mi>225</span><span class=p>),</span>
    <span class=n>point</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>25</span><span class=p>,</span> <span class=mi>125</span><span class=p>)</span>
<span class=p>)</span>

<span class=c1>-- If polygons are not overlapping, nil and false are returned. Otherwise</span>
<span class=c1>-- returns clipping polygon and true.</span>
<span class=kd>local</span> <span class=n>clip</span><span class=p>,</span> <span class=n>overlaps</span> <span class=o>=</span> <span class=n>polygon</span><span class=p>.</span><span class=n>overlaps</span><span class=p>(</span><span class=n>square</span><span class=p>,</span> <span class=n>triangle</span><span class=p>)</span>

<span class=nb>print</span><span class=p>(</span><span class=s2>"Is overlapping: "</span> <span class=o>..</span> <span class=nb>tostring</span><span class=p>(</span><span class=n>overlaps</span><span class=p>))</span>
<span class=kr>if</span> <span class=n>clip</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
    <span class=kr>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>p</span> <span class=kr>in</span> <span class=nb>ipairs</span><span class=p>(</span><span class=n>clip</span><span class=p>)</span> <span class=kr>do</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>"Point "</span> <span class=o>..</span> <span class=n>i</span> <span class=o>..</span> <span class=s2>": {x = "</span> <span class=o>..</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>..</span> <span class=s2>", y = "</span> <span class=o>..</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>..</span> <span class=s2>"}"</span><span class=p>)</span>
    <span class=kr>end</span>
<span class=kr>end</span>
<span class=c1>-- Output:</span>
<span class=cm>--[[</span>
<span class=cm>Is overlapping: true</span>
<span class=cm>Point 1: {x = 109.375, y = 150.0}</span>
<span class=cm>Point 2: {x = 100.0, y = 165.0}</span>
<span class=cm>Point 3: {x = 100, y = 150}</span>
<span class=cm>--]]</span>
</code></pre></div><div class="admonition tip"><p class=admonition-title>Tip<p>If you’re working exclusively with rectangles, use the <code>rectangle</code> module for a simpler and more efficient algorithm. For non-rectangular polygons, opt for the <code>polygon</code> module.</div><h2 id=running-demos>Running demos<a title="Permanent link" class=headerlink href=#running-demos>#</a></h2><p>Demos are written in <a href=https://love2d.org/>Löve2D Framework</a>. To run demos Löve2D should be installed on your machine.<p>Use relative paths for demos; this keeps the import path correct.<div class=codehilite><pre><span></span><code>love<span class=w> </span>./demos/point-inside
love<span class=w> </span>./demos/polygons-intersection
love<span class=w> </span>./demos/rectangles-intersection
</code></pre></div><h2 id=tests>Tests<a title="Permanent link" class=headerlink href=#tests>#</a></h2><p>Unit-tests are performed using <a href=https://github.com/dknight/laura/>Laura testing framework</a>. Linting is performed using <a href=https://github.com/mpeterv/luacheck>luacheck</a>.<p>Unit tests<div class=codehilite><pre><span></span><code>laura<span class=w> </span>.
</code></pre></div><p>Lint (code quality)<div class=codehilite><pre><span></span><code>luacheck<span class=w> </span>src<span class=w> </span><span class=nb>test</span>
</code></pre></div><p>Run everything with <code>make</code> software<div class=codehilite><pre><span></span><code>make<span class=w> </span>lint<span class=w> </span><span class=nb>test</span>
</code></pre></div><h2 id=api>API<a title="Permanent link" class=headerlink href=#api>#</a></h2><h3 id=types>Types<a title="Permanent link" class=headerlink href=#types>#</a></h3><ul><li><code>Point [number, number]</code><li><code>Rectangle [number, number, number, number]</code><li><code>Polygon Point[]</code></ul><h3 id=modules>Modules<a title="Permanent link" class=headerlink href=#modules>#</a></h3><h4 id=point><code>point</code><a title="Permanent link" class=headerlink href=#point>#</a></h4><ul><li><code>new(x: number, y: number): Point</code><br> Creates a new point instance with x and y coordinates.<li><code>distanceTo(p: Point, q: Point): number</code><br> Computes the distance between two points.</ul><h4 id=rectangle><code>rectangle</code><a title="Permanent link" class=headerlink href=#rectangle>#</a></h4><ul><li><code>new(x1: number, y1: number, x2; number, y2: number): Rectangle</code><br><li><code>new(p: Point, q: Point): Rectangle</code><br> Creates a new rectangle instance.<li><code>contains(rect: Rectangle, point: Point): boolean</code><br> Checks is the point inside a rectangle.<li><code>overlaps(rect1: Rectangle, rect2: Rectangle): boolean</code><br> Checks two axis-aligned rectangles for the collision.<li><code>toList(rect: Rectangle): number</code><br> Converts the rectangle to the array of numbers.</ul><h4 id=polygon><code>polygon</code><a title="Permanent link" class=headerlink href=#polygon>#</a></h4><ul><li><code>new(...points: Point[]): Polygon</code><br> Creates a new polygon instance.<li><code>add(...points: Point[]): nil</code><br> Adds point(s) to the polygon.<li><code>toList(): number[]</code><br> Converts polygon to the form of array [x1, y1, x2, y2, y3, y3, …, xN, yN].<li><code>contains(a: Polygon, p: Point): boolean</code><br> Check if a point is inside a polygon <code>a</code> using the winding number method. Point is inside if the winding number is nonzero.<li><code>intersects(p1: Point, p2: Point, q1: Point, q2: Point): Point|nil</code><br> Compute the intersection of two line segments {<code>p1</code>, <code>p2</code>} and {<code>q1</code>, <code>q2</code>}. If segments are parallel or incongruent, it returns <code>nil</code>.<li><code>overlaps(a: Polygon, b: Polygon): Polygon|nil, boolean</code><br> Checks that two polygons are overlapping each other. If polygons do not overlap <code>nil</code> and <code>false</code>, they are returned; otherwise, clipped polygons and <code>true</code> are returned.</ul><h4 id=constant><code>constant</code><a title="Permanent link" class=headerlink href=#constant>#</a></h4><ul><li><code>Epslion: number</code><br> A very small number.</ul><h2 id=references>References<a title="Permanent link" class=headerlink href=#references>#</a></h2><ul><li><a href=https://love2d.org/>Löve2D</a><li><a href=https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm>Weiler-Athethon algorithm</a></ul><h2>Feedback</h2><p>For feedback, please check the <a href=/me/>contacts</a> section. Before writing, please specify where you came from and who you are. Sometimes spammers go insane. Thank you in advance for your understanding.</article><a href=/>← Back to the index page</a></main><footer><hr><p>(c) 2022-2025 <a href=/me/>xdknight</a> Powered by <a href=https://github.com/hmngwy/jenny>Jenny</a> shell blog engine.<p>Any images on this website may be used, copied and redistributed under the <a href=https://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a> license.<p>Any code on this website may be used, copied and redistributed under the <a href=https://opensource.org/license/MIT>MIT</a> license.<p>This website does not use cookies or any tracking techniques either. Also, this page is fully accessible, responsive, and readable on any device without a single line of JavaScript.</footer>