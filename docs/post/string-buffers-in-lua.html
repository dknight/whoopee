<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Working with string in Lua in performant way, using string buffers. " name=description><meta content="lua, programming, algorithms, data-structures, gamedev, game development, blog, personal" name=keywords><meta content="Dmitri Smirnov" name=author><meta content=website property=og:type><meta content=https://www.whoop.ee/post/string-buffers-in-lua.html property=og:url><meta content=https://www.whoop.ee/assets/img/whoopee-logo.png property=og:image><meta content="script-src 'self'" http-equiv=Content-Security-Policy><meta content="object-src 'none'" http-equiv=Content-Security-Policy><title>String buffers in Lua — Whoopee</title><link as=font href=/assets/fonts/Perfect_DOS_VGA_437.woff2 rel=preload><link href=/favicon.ico rel=icon type=image/x-icon><link href=/assets/css/styles.min.css rel=stylesheet><link title="RSS Feed" href=/feed.xml rel=alternate type=application/rss+xml><link href=https://www.whoop.ee/post/string-buffers-in-lua.html rel=canonical><body><header><a href=/><img alt=Whoopee class=logo height=172 src=/assets/img/whoopee-logo.png width=200></a><nav class=mainmenu><a href=/me/>About</a><a href=/feed.xml>RSS</a></nav></header><main><a href=/>← Back to the index page</a><article><h1>String buffers in Lua</h1><time datetime=2024-08-14> August 14, 2024 </time><h2 id=the-problem>The problem<a title="Permanent link" class=headerlink href=#the-problem>#</a></h2><p>When working with strings, using the concatenation operator <code>..</code> looks fine, but there is a pitfall, that might lead to catastrophic performance issues.<p>Consider:<div class=codehilite><pre><span></span><code><span class=s2>"Hello"</span> <span class=o>..</span> <span class=s2>"World"</span> <span class=c1>--> "HelloWorld"</span>
</code></pre></div><p>The statement above is fair only for small strings and short loops. If there is concatenation in the loop, there is a huge performance problem.<div class="admonition danger"><p class=admonition-title>Danger<p>Bad code ahead!</div><p>Consider:<div class=codehilite><pre><span></span><code><span class=kd>local</span> <span class=n>s</span> <span class=o>=</span> <span class=s2>"abcdefghij"</span>
<span class=kd>local</span> <span class=n>buf</span> <span class=o>=</span> <span class=s2>""</span>
<span class=kr>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1000000</span> <span class=kr>do</span>
    <span class=n>buf</span> <span class=o>=</span> <span class=n>buf</span> <span class=o>..</span> <span class=n>s</span> <span class=o>..</span> <span class=s2>"</span><span class=se>\n</span><span class=s2>"</span>
<span class=kr>end</span>
<span class=nb>print</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span>
</code></pre></div><p>At first glance, it seems to be very innocent, but why is it bad? Since strings in Lua are <strong>immutable</strong>, each concatenation creates a new string object and copies the data from the source strings to it. That makes successive concatenations of a single string have very poor performance.<p>Let’s assume we read 10 bytes from each line.<table><thead><tr><th style="text-align: right;">Iteration<th style="text-align: right;">Old string size<th style="text-align: right;">New string size<th style="text-align: right;">Copied memory<tbody><tr><td style="text-align: right;">1<td style="text-align: right;">0<td style="text-align: right;">10<td style="text-align: right;">10<tr><td style="text-align: right;">2<td style="text-align: right;">10<td style="text-align: right;">20<td style="text-align: right;">30<tr><td style="text-align: right;">3<td style="text-align: right;">20<td style="text-align: right;">30<td style="text-align: right;">50<tr><td style="text-align: right;">4<td style="text-align: right;">30<td style="text-align: right;">40<td style="text-align: right;">70<tr><td style="text-align: right;">5<td style="text-align: right;">40<td style="text-align: right;">50<td style="text-align: right;">90<tr><td style="text-align: right;">…<td style="text-align: right;">…<td style="text-align: right;">…<td style="text-align: right;">…<tr><td style="text-align: right;">1999<td style="text-align: right;">19980<td style="text-align: right;">19990<td style="text-align: right;">20000<tr><td style="text-align: right;">2000<td style="text-align: right;">19990<td style="text-align: right;">20000<td style="text-align: right;">20010<tr><td style="text-align: right;"><td style="text-align: right;"><td style="text-align: right;"><strong>Total</strong><td style="text-align: right;"><strong>19992000</strong></table><p>Let’s continue to the 1999th iteration. A new string will be created with a length of 20,000 bytes. Lua needs to allocate 20,000 bytes of memory and copy old and new strings into this buffer. In every iteration, Lua should allocate more and more memory to newly created strings. There is also more memory to clean up the old strings, which must be cleaned by the garbage collector. This procedure has <em>O(n<sup>2</sup>)</em> complexity, which is the worst for such a simple task.<p><img alt="Figure 01: String concatenation problem" src=/assets/img/string-buffers.svg><h2 id=solution>Solution<a title="Permanent link" class=headerlink href=#solution>#</a></h2><p>This problem is not valid only for Lua; most of the C-like languages have the same issues with memory allocation. To avoid this, other languages like Java have <code>StringBuffer</code> and <code>StringBuilder</code> classes; in Go, there are <code>bytes.Buffer</code> and <code>strings.Builder</code>, etc. In Lua, there is an old-good <code>table</code> data structure for this purpose. The initial example can be rewritten using <code>table.concat()</code>, as follows:<div class=codehilite><pre><span></span><code><span class=kd>local</span> <span class=n>s</span> <span class=o>=</span> <span class=s2>"abcdefghij"</span>
<span class=kd>local</span> <span class=n>buf</span> <span class=o>=</span> <span class=p>{}</span>
<span class=kr>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1000000</span> <span class=kr>do</span>
    <span class=n>buf</span><span class=p>[</span><span class=o>#</span><span class=n>buf</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>s</span>
<span class=kr>end</span>
<span class=nb>table.concat</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s2>"</span><span class=se>\n</span><span class=s2>"</span><span class=p>)</span>
</code></pre></div><p>The code above is 1000+ times faster than using <code>..</code> operator in the loop.<h2 id=going-deeper>Going deeper<a title="Permanent link" class=headerlink href=#going-deeper>#</a></h2><p>It is good to know why <code>table.concat()</code> is so much faster than concatenations. If we check Lua’s source code (<a href=https://www.lua.org/source/5.4/ltablib.c.html#tconcat>ltablib.c</a>) for the <code>table.concat()</code> function, it is not hard to understand that it uses the stack data structure.<p>Demonstration of implementation using <a href=/post/stack.html>a stack data structure</a>. This is definitely slower than <code>table.concat()</code> because the Lua standard library is compiled into binary from C code. Still, home-made stack implementation is much faster than only concatenations.<div class=codehilite><pre><span></span><code><span class=kd>local</span> <span class=n>Stack</span> <span class=o>=</span> <span class=nb>require</span><span class=p>(</span><span class=s2>"Stack"</span><span class=p>)</span>

<span class=c1>-- Create an empty stack</span>
<span class=kd>local</span> <span class=n>stack</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>

<span class=c1>-- Start with an empty string</span>
<span class=n>stack</span><span class=p>:</span><span class=n>push</span><span class=p>(</span><span class=s2>""</span><span class=p>)</span>

<span class=c1>--- Add 1 million records</span>
<span class=kr>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1000000</span> <span class=kr>do</span>
    <span class=n>stack</span><span class=p>:</span><span class=n>push</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
    <span class=kr>for</span> <span class=n>j</span> <span class=o>=</span> <span class=o>#</span><span class=n>stack</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span> <span class=kr>do</span>
        <span class=kr>if</span> <span class=nb>string.len</span><span class=p>(</span><span class=n>stack</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>></span> <span class=nb>string.len</span><span class=p>(</span><span class=n>stack</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span> <span class=kr>then</span>
            <span class=kr>break</span>
        <span class=kr>end</span>
        <span class=n>stack</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>stack</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>..</span> <span class=nb>table.remove</span><span class=p>(</span><span class=n>stack</span><span class=p>)</span>
    <span class=kr>end</span>
<span class=kr>end</span>
</code></pre></div><h2 id=benchmarking>Benchmarking<a title="Permanent link" class=headerlink href=#benchmarking>#</a></h2><p>I use my old Lenovo laptop (3.7GHz 4-core, 8Gb RAM) to benchmark the code. Even with the rough benchmarking, using <code>time</code> utility, the results are self-explanatory: <strong>the difference is about an hour</strong>!<h3 id=code-with-table-buffer-the-fastest>Code with table buffer (the fastest)<a title="Permanent link" class=headerlink href=#code-with-table-buffer-the-fastest>#</a></h3><div class=codehilite><pre><span></span><code>real    0m0.091s
user    0m0.072s
sys     0m0.018s
</code></pre></div><h3 id=code-with-stack-the-class-fast>Code with Stack the class (fast)<a title="Permanent link" class=headerlink href=#code-with-stack-the-class-fast>#</a></h3><div class=codehilite><pre><span></span><code>real    0m0.592s
user    0m0.563s
sys     0m0.021s
</code></pre></div><h3 id=code-with-concatenation-incredibly-slow>Code with concatenation (incredibly slow)<a title="Permanent link" class=headerlink href=#code-with-concatenation-incredibly-slow>#</a></h3><div class=codehilite><pre><span></span><code>real    55m16.051s
user    25m52.709s
sys     27m0.053s
</code></pre></div><h2 id=conclusion>Conclusion<a title="Permanent link" class=headerlink href=#conclusion>#</a></h2><p>First of all, if there is a need to concatenate strings in the loop, it is a good idea to stop for a moment and think twice. For small strings or short loops, the <code>..</code> concatenation operator is OK. But for longer strings and long loops with concatenation, <code>table.concat()</code> is worth trying to significantly improve the performance.<h2 id=references>References<a title="Permanent link" class=headerlink href=#references>#</a></h2><ul><li><a href=https://www.lua.org/manual/5.4/manual.html#3.4.6>Lua Manual: 3.4.6 Concatenation</a><li><a href=https://www.lua.org/pil/11.6.html>Programming In Lua: 11.6 String Buffers</a></ul><h2>Feedback</h2><p>For feedback, please check the <a href=/me/>contacts</a> section. Before writing, please specify where you came from and who you are. Sometimes spammers go insane. Thank you in advance for your understanding.</article><a href=/>← Back to the index page</a></main><footer><hr><p>(c) 2022-2025 <a href=/me/>xdknight</a> Powered by <a href=https://github.com/hmngwy/jenny>Jenny</a> shell blog engine.<p>Any images on this website may be used, copied and redistributed under the <a href=https://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a> license.<p>Any code on this website may be used, copied and redistributed under the <a href=https://opensource.org/license/MIT>MIT</a> license.<p>This website does not use cookies or any tracking techniques either. Also, this page is fully accessible, responsive, and readable on any device without a single line of JavaScript.</footer>