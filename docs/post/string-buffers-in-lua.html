<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Working with string in Lua in performant way, using string buffers. "><meta name="keywords" content="lua, programming, algorithms, data-structures, gamedev, game development, blog, personal"><meta name="author" content="Dmitri Smirnov"><meta property="og:type" content="website"><meta property="og:url" content="https://www.whoop.ee/post/string-buffers-in-lua.html"><meta property="og:image" content="https://www.whoop.ee/assets/img/lua-language.gif"><meta http-equiv="Content-Security-Policy" content="script-src 'self'"><meta http-equiv="Content-Security-Policy" content="object-src 'none'"><title>String buffers in Lua &mdash; Whoopee</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="stylesheet" href="/assets/css/styles.min.css"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml"><link rel="canonical" href="https://www.whoop.ee/post/string-buffers-in-lua.html"></head><body><header><a href="/" class="logo">Whoopee</a><nav class="mainmenu"><a href="/me/">About</a> <a href="/feed.xml">RSS</a></nav></header><main><a href="/"><em>&larr; Back to the index page</em></a><article><h1>String buffers in Lua</h1><time datetime="2024-08-14">August 14, 2024</time><h2 id="the-problem">The problem<a class="headerlink" href="#the-problem" title="Permanent link">&para;</a></h2><p>When working with strings, using the concatenation operator <code>..</code> looks fine, but there is a pitfall, that might lead to catastrophic performance issues.</p><p>Consider:</p><div class="codehilite"><pre><span></span><code><span class="s2">&quot;Hello&quot;</span> <span class="o">..</span> <span class="s2">&quot;World&quot;</span> <span class="c1">--&gt; &quot;HelloWorld&quot;</span>
</code></pre></div><p>The statement above is fair only for small strings and short loops. If there is concatenation in the loop, there is a huge performance problem.</p><div class="admonition danger"><p class="admonition-title">Danger</p><p>Bad code ahead!</p></div><p>Consider:</p><div class="codehilite"><pre><span></span><code><span class="kd">local</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;abcdefghij&quot;</span>
<span class="kd">local</span> <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="kr">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000000</span> <span class="kr">do</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">..</span> <span class="n">s</span> <span class="o">..</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="kr">end</span>
<span class="nb">print</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</code></pre></div><p>At first glance, it seems to be very innocent, but why is it bad? Since strings in Lua are <strong>immutable</strong>, each concatenation creates a new string object and copies the data from the source strings to it. That makes successive concatenations of a single string have very poor performance.</p><p>Let&rsquo;s assume we read 10 bytes from each line.</p><table><thead><tr><th style="text-align: right;">Iteration</th><th style="text-align: right;">Old string size</th><th style="text-align: right;">New string size</th><th style="text-align: right;">Copied memory</th></tr></thead><tbody><tr><td style="text-align: right;">1</td><td style="text-align: right;">0</td><td style="text-align: right;">10</td><td style="text-align: right;">10</td></tr><tr><td style="text-align: right;">2</td><td style="text-align: right;">10</td><td style="text-align: right;">20</td><td style="text-align: right;">30</td></tr><tr><td style="text-align: right;">3</td><td style="text-align: right;">20</td><td style="text-align: right;">30</td><td style="text-align: right;">50</td></tr><tr><td style="text-align: right;">4</td><td style="text-align: right;">30</td><td style="text-align: right;">40</td><td style="text-align: right;">70</td></tr><tr><td style="text-align: right;">5</td><td style="text-align: right;">40</td><td style="text-align: right;">50</td><td style="text-align: right;">90</td></tr><tr><td style="text-align: right;">&hellip;</td><td style="text-align: right;">&hellip;</td><td style="text-align: right;">&hellip;</td><td style="text-align: right;">&hellip;</td></tr><tr><td style="text-align: right;">1999</td><td style="text-align: right;">19980</td><td style="text-align: right;">19990</td><td style="text-align: right;">20000</td></tr><tr><td style="text-align: right;">2000</td><td style="text-align: right;">19990</td><td style="text-align: right;">20000</td><td style="text-align: right;">20010</td></tr><tr><td style="text-align: right;"></td><td style="text-align: right;"></td><td style="text-align: right;"><strong>Total</strong></td><td style="text-align: right;"><strong>19992000</strong></td></tr></tbody></table><p>Let&rsquo;s continue to the 1999th iteration. A new string will be created with a length of 20,000 bytes. Lua needs to allocate 20,000 bytes of memory and copy old and new strings into this buffer. In every iteration, Lua should allocate more and more memory to newly created strings. There is also more memory to clean up the old strings, which must be cleaned by the garbage collector. This procedure has <em>O(n<sup>2</sup>)</em> complexity, which is the worst for such a simple task.</p><p><img alt="Figure 01: String concatenation problem" src="/assets/img/string-buffers.svg"></p><h2 id="solution">Solution<a class="headerlink" href="#solution" title="Permanent link">&para;</a></h2><p>This problem is not valid only for Lua; most of the C-like languages have the same issues with memory allocation. To avoid this, other languages like Java have <code>StringBuffer</code> and <code>StringBuilder</code> classes; in Go, there are <code>bytes.Buffer</code> and <code>strings.Builder</code>, etc. In Lua, there is an old-good <code>table</code> data structure for this purpose. The initial example can be rewritten using <code>table.concat()</code>, as follows:</p><div class="codehilite"><pre><span></span><code><span class="kd">local</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;abcdefghij&quot;</span>
<span class="kd">local</span> <span class="n">buf</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kr">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000000</span> <span class="kr">do</span>
    <span class="n">buf</span><span class="p">[</span><span class="o">#</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
<span class="kr">end</span>
<span class="nb">table.concat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div><p>The code above is 1000+ times faster than using <code>..</code> operator in the loop.</p><h2 id="going-deeper">Going deeper<a class="headerlink" href="#going-deeper" title="Permanent link">&para;</a></h2><p>It is good to know why <code>table.concat()</code> is so much faster than concatenations. If we check Luaâ€™s source code (<a href="https://www.lua.org/source/5.4/ltablib.c.html#tconcat">ltablib.c</a>) for the <code>table.concat()</code> function, it is not hard to understand that it uses the stack data structure.</p><p>Demonstration of implementation using <a href="/post/stack.html">a stack data structure</a>. This is definitely slower than <code>table.concat()</code> because the Lua standard library is compiled into binary from C code. Still, home-made stack implementation is much faster than only concatenations.</p><div class="codehilite"><pre><span></span><code><span class="kd">local</span> <span class="n">Stack</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&quot;Stack&quot;</span><span class="p">)</span>

<span class="c1">-- Create an empty stack</span>
<span class="kd">local</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>

<span class="c1">-- Start with an empty string</span>
<span class="n">stack</span><span class="p">:</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="c1">--- Add 1 million records</span>
<span class="kr">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000000</span> <span class="kr">do</span>
    <span class="n">stack</span><span class="p">:</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="kr">for</span> <span class="n">j</span> <span class="o">=</span> <span class="o">#</span><span class="n">stack</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">do</span>
        <span class="kr">if</span> <span class="nb">string.len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">string.len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="kr">then</span>
            <span class="kr">break</span>
        <span class="kr">end</span>
        <span class="n">stack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">..</span> <span class="nb">table.remove</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
    <span class="kr">end</span>
<span class="kr">end</span>
</code></pre></div><h2 id="benchmarking">Benchmarking<a class="headerlink" href="#benchmarking" title="Permanent link">&para;</a></h2><p>I use my old Lenovo laptop (3.7GHz 4-core, 8Gb RAM) to benchmark the code. Even with the rough benchmarking, using <code>time</code> utility, the results are self-explanatory: <strong>the difference is about an hour</strong>!</p><h3 id="code-with-table-buffer-the-fastest">Code with table buffer (the fastest)<a class="headerlink" href="#code-with-table-buffer-the-fastest" title="Permanent link">&para;</a></h3><div class="codehilite"><pre><span></span><code>real    0m0.091s
user    0m0.072s
sys     0m0.018s
</code></pre></div><h3 id="code-with-stack-the-class-fast">Code with Stack the class (fast)<a class="headerlink" href="#code-with-stack-the-class-fast" title="Permanent link">&para;</a></h3><div class="codehilite"><pre><span></span><code>real    0m0.592s
user    0m0.563s
sys     0m0.021s
</code></pre></div><h3 id="code-with-concatenation-incredibly-slow">Code with concatenation (incredibly slow)<a class="headerlink" href="#code-with-concatenation-incredibly-slow" title="Permanent link">&para;</a></h3><div class="codehilite"><pre><span></span><code>real    55m16.051s
user    25m52.709s
sys     27m0.053s
</code></pre></div><h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2><p>First of all, if there is a need to concatenate strings in the loop, it is a good idea to stop for a moment and think twice. For small strings or short loops, the <code>..</code> concatenation operator is OK. But for longer strings and long loops with concatenation, <code>table.concat()</code> is worth trying to significantly improve the performance.</p><h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2><ul><li><a href="https://www.lua.org/manual/5.4/manual.html#3.4.6">Lua Manual: 3.4.6 Concatenation</a></li><li><a href="https://www.lua.org/pil/11.6.html">Programming In Lua: 11.6 String Buffers</a></li></ul><h2>Feedback</h2><p>For feedback, please check the <a href="/me/">contacts</a> section. Before writing, please specify where you came from and who you are. Sometimes spammers go insane. Thank you in advance for your understanding.</p></article><a href="/"><em>&larr; Back to the index page</em></a></main><footer><hr><p>&copy; 2022&mdash;2025 <a href="/me/">xdknight</a> Powered by <a href="https://github.com/hmngwy/jenny">Jenny</a> shell blog engine. <a href="https://github.com/dknight/whoopee">Source code</a></p><p>Any images on this website may be used, copied and redistributed under the <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> license.</p><p>Any code on this website may be used, copied and redistributed under the <a href="https://opensource.org/license/MIT">MIT</a> license.</p><p>This website <strong>does not</strong> use cookies or any tracking techniques either. Also, this page is fully accessible, responsive, and readable on any device without a single line of <abbr title="Tool of evil">JavaScript</abbr>.</p></footer></body></html>