<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Definitive guide and implementation of the binary tree in Lua language. Binary is one of the most important data structures, used in different kinds of advanced algorithms, like pathfinding, detecting cycles, logistics, maps, etc. " name=description><meta content="lua, programming, algorithms, data-structures, gamedev, game development, blog, personal" name=keywords><meta content="Dmitri Smirnov" name=author><meta content=website property=og:type><meta content=https://www.whoop.ee/post/binary-tree.html property=og:url><meta content=https://www.whoop.ee/assets/img/whoopee-logo-black.png property=og:image><meta content="script-src 'self'" http-equiv=Content-Security-Policy><meta content="object-src 'none'" http-equiv=Content-Security-Policy><title>Binary tree — Whoopee</title><link as=font href=/assets/fonts/Perfect_DOS_VGA_437.woff2 rel=preload><link href=/favicon.ico rel=icon type=image/x-icon><link href=/assets/css/styles.min.css rel=stylesheet><link title="RSS Feed" href=/feed.xml rel=alternate type=application/rss+xml><link href=https://www.whoop.ee/post/binary-tree.html rel=canonical><body><header><a href=/><img alt=Whoopee class=logo height=172 src=/assets/img/whoopee-logo.png width=200></a><nav class=mainmenu><a class=mainmenu-toolbox href=/post/lua-toolbox.html>Lua Toolbox</a><a class=mainmenu-about href=/me/>About</a><a class=mainmenu-rss href=/feed.xml>RSS</a></nav></header><main><a href=/>← Back to the index page</a><article><h1>Binary tree</h1><time datetime=2025-03-29> March 29, 2025 </time><div><input class=toc-toggle id=toc-toggle type=checkbox><label for=toc-toggle>Table of contents</label></div><div class=toc><ul><li><a href=#binary-tree>Binary tree</a><ul><li><a href=#structure-of-binary-tree>Structure of Binary Tree</a><li><a href=#building-binary-tree>Building Binary tree</a><ul><li><a href=#binary-tree-module>Binary Tree module</a><li><a href=#building-binary-tree-as-the-diagram>Building Binary Tree as the diagram</a></ul><li><a href=#binary-tree-operations>Binary Tree operations</a><ul><li><a href=#traverse>Traverse</a><ul><li><a href=#depth-first-search-dfs-algorithms>Depth-First Search (DFS) algorithms</a><ul><li><a href=#pre-order-traversal>Pre-order Traversal</a><li><a href=#post-order-traversal>Post-order Traversal</a><li><a href=#in-order-traversal>In-order Traversal</a></ul><li><a href=#breadth-first-search-bfs>Breadth-First Search (BFS)</a></ul><li><a href=#searching>Searching</a><li><a href=#insertion>Insertion</a><li><a href=#deletion>Deletion</a><li><a href=#get-size-of-the-tree>Get size of the tree</a><li><a href=#get-level-depth-of-a-node>Get level (depth) of a node</a><li><a href=#get-the-height-depth-of-the-tree>Get the height (depth) of the tree</a></ul><li><a href=#binarytreelua>BinaryTree.lua</a><ul><li><a href=#usage-of-binarytree-class>Usage of BinaryTree class</a></ul></ul></ul></div><p>A <strong>Binary Tree</strong> is a non-linear and hierarchical data structure where each node can have up to two children, known as the <strong>left child</strong> and <strong>right child</strong>. It is widely used in computer science and makes it easy to store and retrieve data by letting you do things like adding, deleting, and traversing. The topmost node in a binary tree is called the <strong>root</strong>, and the bottom-most nodes are called leaves.<h2 id=structure-of-binary-tree>Structure of Binary Tree<a title="Permanent link" class=headerlink href=#structure-of-binary-tree>#</a></h2><p><img alt="Example of Binary tree Data Structure" src=/assets/img/binary-tree-01.svg><ul><li><strong>Nodes</strong>: The core components of a binary tree, each containing data and links to two child nodes (left and right).<li><strong>Root</strong>: The highest node in the tree, which has no parent and acts as the origin of all other nodes.<li><strong>Parent node</strong>: A node that has one or more children. <strong>In a binary tree, a parent node can have at most two child nodes</strong>.<li><strong>Child node</strong>: A node that descends from another node (its parent), categorized as either a left or right child.<li><strong>Leaf node</strong>: A node without any children. In Lua, this means both of its child nodes are <code>nil</code>.<li><strong>Height of binary tree</strong>: The count of nodes along the longest path from the root to the deepest leaf, or the total number of levels.<li><strong>Depth of a node</strong>: The number of edges between a given node and the root. The root node has a depth of <code>0</code>.<li><strong>Subtree</strong>: A section of the tree that forms its own hierarchy, often represented as a magenta triangle in a diagram above.</ul><h2 id=building-binary-tree>Building Binary tree<a title="Permanent link" class=headerlink href=#building-binary-tree>#</a></h2><h3 id=binary-tree-module>Binary Tree module<a title="Permanent link" class=headerlink href=#binary-tree-module>#</a></h3><p>First, let’s create a class <code>BinaryTree</code> with a static method <code>createNode</code> Also, here we can define type <code>Node</code> to improve <abbr title="Developer Experience">DX</abbr>.<div class=codehilite><pre><span></span><code><span class=c1>---@class BinaryTree</span>
<span class=kd>local</span> <span class=n>BinaryTree</span> <span class=o>=</span> <span class=p>{</span>
    <span class=c1>---Create a new node</span>
    <span class=c1>---@param data any</span>
    <span class=c1>---@return Node</span>
    <span class=n>createNode</span> <span class=o>=</span> <span class=kr>function</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=kr>return</span> <span class=p>{</span>
            <span class=n>left</span> <span class=o>=</span> <span class=kc>nil</span><span class=p>,</span>
            <span class=n>right</span> <span class=o>=</span> <span class=kc>nil</span><span class=p>,</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=p>,</span>
        <span class=p>}</span>
    <span class=kr>end</span><span class=p>,</span>
<span class=p>}</span>
<span class=n>BinaryTree</span><span class=p>.</span><span class=n>__index</span> <span class=o>=</span> <span class=n>BinaryTree</span>

<span class=c1>---Creates new Binary Tree</span>
<span class=c1>---@return BinaryTree</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>new</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>t</span> <span class=o>=</span> <span class=p>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=kc>nil</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=kr>return</span> <span class=nb>setmetatable</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>self</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><h3 id=building-binary-tree-as-the-diagram>Building Binary Tree as the diagram<a title="Permanent link" class=headerlink href=#building-binary-tree-as-the-diagram>#</a></h3><p>To build a tree, we need to create nodes and make relations between them.<div class=codehilite><pre><span></span><code><span class=kd>local</span> <span class=n>a</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"A"</span><span class=p>)</span> <span class=c1>-- root</span>
<span class=kd>local</span> <span class=n>b</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"B"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>c</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"C"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>d</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"D"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>e</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"E"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>f</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"F"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>g</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"G"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>h</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"H"</span><span class=p>)</span>

<span class=kd>local</span> <span class=n>btree</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
<span class=n>btree</span><span class=p>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>a</span>

<span class=n>a</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>b</span>
<span class=n>a</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>c</span>
<span class=n>b</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>d</span>
<span class=n>b</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>e</span>
<span class=n>e</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>g</span>
<span class=n>e</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>h</span>
<span class=n>c</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>f</span>
</code></pre></div><h2 id=binary-tree-operations>Binary Tree operations<a title="Permanent link" class=headerlink href=#binary-tree-operations>#</a></h2><h3 id=traverse>Traverse<a title="Permanent link" class=headerlink href=#traverse>#</a></h3><p>Traversal in a binary tree involves visiting all the nodes of the binary tree. Like in <a href=/post/graph.html>graphs</a> traversal algorithms can be classified broadly into two categories, <strong><abbr title="Depth-First Search">DFS</abbr></strong> and <strong><abbr title="Breadth-First Search">BFS</abbr></strong>. Here we use <code>callback</code> pattern to make operations with the node on traversal.<div class=codehilite><pre><span></span><code><span class=c1>---@alias BinaryTreeCallback fun(node: Node)</span>
</code></pre></div><h4 id=depth-first-search-dfs-algorithms>Depth-First Search (<abbr title="Depth-First Search">DFS</abbr>) algorithms<a title="Permanent link" class=headerlink href=#depth-first-search-dfs-algorithms>#</a></h4><p><abbr title="Depth-First Search">DFS</abbr> explores as far down a branch as possible before backtracking. It is implemented using recursion. The main traversal methods in <abbr title="Depth-First Search">DFS</abbr> for binary trees.<h5 id=pre-order-traversal>Pre-order Traversal<a title="Permanent link" class=headerlink href=#pre-order-traversal>#</a></h5><p>Visits the node first, then the left subtree, then the right subtree.<div class=codehilite><pre><span></span><code><span class=c1>---Pre-order DFS: Root, Left, Right</span>
<span class=c1>---@param node Node | nil</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>preOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
        <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><h5 id=post-order-traversal>Post-order Traversal<a title="Permanent link" class=headerlink href=#post-order-traversal>#</a></h5><p>Visits the left subtree, then the right subtree, then the node.<div class=codehilite><pre><span></span><code><span class=c1>---Post-order DFS: Left, Right, Root</span>
<span class=c1>---@param node Node | nil</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>postOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>postOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>postOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
        <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=kr>end</span>
<span class=kr>end</span>
</code></pre></div><h5 id=in-order-traversal>In-order Traversal<a title="Permanent link" class=headerlink href=#in-order-traversal>#</a></h5><p>Visits the left subtree, then the node, then the right subtree.<div class=codehilite><pre><span></span><code><span class=c1>---In-order DFS: Left, Root, Right</span>
<span class=c1>---@param node Node</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>inOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>inOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
        <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>inOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><h4 id=breadth-first-search-bfs>Breadth-First Search (<abbr title="Breadth-First Search">BFS</abbr>)<a title="Permanent link" class=headerlink href=#breadth-first-search-bfs>#</a></h4><p><abbr title="Breadth-First Search">BFS</abbr> explores all nodes at the present depth before moving on to nodes at the next depth level. It is typically implemented using a <a href=/post/queue.html>queue</a>.<div class=codehilite><pre><span></span><code><span class=c1>---BFS: Level order traversal</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>BFS</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=kd>local</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>
        <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
            <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
<span class=kr>end</span>
</code></pre></div><h3 id=searching>Searching<a title="Permanent link" class=headerlink href=#searching>#</a></h3><p>Searching for a value in a binary tree means looking through the tree to find a node that has that value. Since binary trees do not have a specific order like binary search trees, we typically use any <a href=#traverse>traversal method</a> to search. It is good to define <code>predicate</code> type to make possible more complex search comparisons.<div class=codehilite><pre><span></span><code><span class=c1>---@alias BinaryTreePredicate fun(node: Node, needle: any): boolean </span>
</code></pre></div><div class=codehilite><pre><span></span><code><span class=c1>---Checks that value has a node</span>
<span class=c1>---@param node Node | nil</span>
<span class=c1>---@param needle any</span>
<span class=c1>---@param predicate BinaryTreePredicate</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>contains</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>needle</span><span class=p>,</span> <span class=n>predicate</span><span class=p>)</span>
    <span class=c1>-- Base case: If the tree is empty or we've reached</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=kc>false</span>
    <span class=kr>end</span>

    <span class=c1>-- If the node's data is equal to the value we are searching for.</span>
    <span class=kr>if</span> <span class=n>predicate</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>needle</span><span class=p>)</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=kc>true</span>
    <span class=kr>end</span>

    <span class=c1>-- Recursively search in the left and right subtrees</span>
    <span class=kd>local</span> <span class=n>leftFound</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>contains</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>needle</span><span class=p>,</span> <span class=n>predicate</span><span class=p>)</span>
    <span class=kd>local</span> <span class=n>rightFound</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>contains</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>needle</span><span class=p>,</span> <span class=n>predicate</span><span class=p>)</span>

    <span class=kr>return</span> <span class=n>leftFound</span> <span class=ow>or</span> <span class=n>rightFound</span>
<span class=kr>end</span>
</code></pre></div><h3 id=insertion>Insertion<a title="Permanent link" class=headerlink href=#insertion>#</a></h3><p>Inserting elements into a binary tree involves adding a new node. Since a binary tree does not follow a specific ordering of elements, there is no need to consider their arrangement. If the tree is empty, the first step is to create a root node. For subsequent insertions, the process involves iteratively searching each level of the tree for an available spot. When an empty left or right child is found, the new node is inserted in that position. By convention, insertion begins with the left child node.<div class=codehilite><pre><span></span><code><span class=c1>---Inserts new element to the binary tree.</span>
<span class=c1>---@param data any</span>
<span class=c1>---@return Node</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>insert</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=kr>return</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>end</span>
    <span class=kd>local</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>

        <span class=kr>if</span> <span class=n>temp</span><span class=p>.</span><span class=n>left</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>temp</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
            <span class=kr>break</span>
        <span class=kr>else</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>temp</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>end</span>

        <span class=kr>if</span> <span class=n>temp</span><span class=p>.</span><span class=n>right</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>temp</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
            <span class=kr>break</span>
        <span class=kr>else</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>temp</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=n>root</span>
<span class=kr>end</span>
</code></pre></div><h3 id=deletion>Deletion<a title="Permanent link" class=headerlink href=#deletion>#</a></h3><p>Deleting a node from a binary tree involves removing a specific node while maintaining the tree’s structure. First, locate the node to be deleted by traversing the tree using any traversal method. Then, replace its value with the value of the last node in the tree, which can be found by navigating to the rightmost leaf. After that, delete the last node to preserve the tree’s structure. It is essential to handle special cases, such as deleting from an empty tree, to prevent errors.<div class="admonition tip"><p class=admonition-title>Tip<p>There is no fixed rule for deletion, but it is crucial to ensure that the fundamental properties of the binary tree are maintained.</div><div class=codehilite><pre><span></span><code><span class=c1>---Deletes an element from the binary tree.</span>
<span class=c1>---@param data any</span>
<span class=c1>---@return Node | nil</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>delete</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=kc>nil</span>
    <span class=kr>end</span>
    <span class=kd>local</span> <span class=n>target</span>
    <span class=kd>local</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>currNode</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>

        <span class=kr>if</span> <span class=n>currNode</span><span class=p>.</span><span class=n>data</span> <span class=o>==</span> <span class=n>data</span> <span class=kr>then</span>
            <span class=n>target</span> <span class=o>=</span> <span class=n>currNode</span>
            <span class=kr>break</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>currNode</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currNode</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>currNode</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currNode</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
    <span class=kr>if</span> <span class=n>target</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>end</span>

    <span class=c1>-- Find the deepest rightmost node and its parent</span>
    <span class=kd>local</span> <span class=n>lastNode</span><span class=p>,</span> <span class=n>lastParent</span>
    <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>parentQueue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>currentNode</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>
        <span class=kd>local</span> <span class=n>parentNode</span> <span class=o>=</span> <span class=n>parentQueue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>
        <span class=n>lastNode</span> <span class=o>=</span> <span class=n>currentNode</span>
        <span class=n>lastParent</span> <span class=o>=</span> <span class=n>parentNode</span>

        <span class=kr>if</span> <span class=n>currentNode</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
            <span class=n>parentQueue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>currentNode</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
            <span class=n>parentQueue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>

    <span class=c1>-- Replace target's value with the last node's value</span>
    <span class=n>target</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>lastNode</span><span class=p>.</span><span class=n>data</span>

    <span class=c1>-- Remove the last node</span>
    <span class=kr>if</span> <span class=n>lastParent</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>if</span> <span class=n>lastParent</span><span class=p>.</span><span class=n>left</span> <span class=o>==</span> <span class=n>lastNode</span> <span class=kr>then</span>
            <span class=n>lastParent</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>nil</span>
        <span class=kr>else</span>
            <span class=n>lastParent</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>nil</span>
        <span class=kr>end</span>
    <span class=kr>else</span>
        <span class=kr>return</span> <span class=kc>nil</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
<span class=kr>end</span>
</code></pre></div><h3 id=get-size-of-the-tree>Get size of the tree<a title="Permanent link" class=headerlink href=#get-size-of-the-tree>#</a></h3><p>Calculates the number of nodes in the binary tree.<div class=codehilite><pre><span></span><code><span class=c1>---Gets the number of nodes in BinaryTree.</span>
<span class=c1>---@return number</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>size</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>self</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>()</span>
        <span class=n>n</span> <span class=o>=</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span>
    <span class=kr>end</span><span class=p>)</span>
    <span class=kr>return</span> <span class=n>n</span>
<span class=kr>end</span>
</code></pre></div><h3 id=get-level-depth-of-a-node>Get level (depth) of a node<a title="Permanent link" class=headerlink href=#get-level-depth-of-a-node>#</a></h3><p>Gets how deep the node is.<div class=codehilite><pre><span></span><code><span class=c1>---Gets the depth of the given node. 0 is for the root node, -1 if tree is empty.</span>
<span class=c1>---@param target any</span>
<span class=c1>---@param level? number</span>
<span class=c1>---@param node? Node | nil</span>
<span class=c1>---@return number</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>getLevel</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>node</span><span class=p>)</span>
    <span class=n>level</span> <span class=o>=</span> <span class=n>level</span> <span class=ow>or</span> <span class=mi>0</span>
    <span class=n>node</span> <span class=o>=</span> <span class=n>node</span> <span class=ow>or</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>end</span>

    <span class=kr>if</span> <span class=n>target</span> <span class=o>==</span> <span class=n>node</span><span class=p>.</span><span class=n>data</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=n>level</span>
    <span class=kr>end</span>

    <span class=kd>local</span> <span class=n>leftLevel</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=n>leftLevel</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>if</span> <span class=n>leftLevel</span> <span class=o>~=</span> <span class=o>-</span><span class=mi>1</span> <span class=kr>then</span>
            <span class=kr>return</span> <span class=n>leftLevel</span>
        <span class=kr>end</span>
    <span class=kr>end</span>

    <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=o>-</span><span class=mi>1</span>
<span class=kr>end</span>
</code></pre></div><h3 id=get-the-height-depth-of-the-tree>Get the height (depth) of the tree<a title="Permanent link" class=headerlink href=#get-the-height-depth-of-the-tree>#</a></h3><p>Get the total levels (depth or height) of the binary tree.<div class=codehilite><pre><span></span><code><span class=c1>---@param node Node | nil</span>
<span class=c1>---@return number</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>getHeight</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=n>node</span> <span class=o>=</span> <span class=n>node</span> <span class=ow>or</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>end</span>

    <span class=kd>local</span> <span class=n>leftHeight</span> <span class=o>=</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=ow>and</span> <span class=n>self</span><span class=p>:</span><span class=n>getHeight</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>)</span> <span class=ow>or</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kd>local</span> <span class=n>rightHeight</span> <span class=o>=</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=ow>and</span> <span class=n>self</span><span class=p>:</span><span class=n>getHeight</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>)</span> <span class=ow>or</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>return</span> <span class=nb>math.max</span><span class=p>(</span><span class=n>leftHeight</span><span class=p>,</span> <span class=n>rightHeight</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
<span class=kr>end</span>
</code></pre></div><h2 id=binarytreelua><code>BinaryTree.lua</code><a title="Permanent link" class=headerlink href=#binarytreelua>#</a></h2><div class=codehilite><pre><span></span><code><span class=kd>local</span> <span class=n>Queue</span> <span class=o>=</span> <span class=nb>require</span><span class=p>(</span><span class=s2>"./Queue"</span><span class=p>)</span>

<span class=c1>---@class Node</span>
<span class=c1>---@field public left Node | nil</span>
<span class=c1>---@field public right Node | nil</span>
<span class=c1>---@field public data any</span>

<span class=c1>---@alias BinaryTreeCallback fun(node: Node)</span>
<span class=c1>---@alias BinaryTreePredicate fun(node: Node, needle: any): boolean</span>

<span class=c1>---@BinaryTreePredicate</span>
<span class=kd>local</span> <span class=n>compare</span> <span class=o>=</span> <span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
    <span class=kr>return</span> <span class=n>node</span><span class=p>.</span><span class=n>data</span> <span class=o>==</span> <span class=n>value</span>
<span class=kr>end</span>

<span class=c1>---@class BinaryTree</span>
<span class=kd>local</span> <span class=n>BinaryTree</span> <span class=o>=</span> <span class=p>{</span>
    <span class=c1>---Create a new node</span>
    <span class=c1>---@param data any</span>
    <span class=c1>---@return Node</span>
    <span class=n>createNode</span> <span class=o>=</span> <span class=kr>function</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=kr>return</span> <span class=p>{</span>
            <span class=n>left</span> <span class=o>=</span> <span class=kc>nil</span><span class=p>,</span>
            <span class=n>right</span> <span class=o>=</span> <span class=kc>nil</span><span class=p>,</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=p>,</span>
        <span class=p>}</span>
    <span class=kr>end</span><span class=p>,</span>
<span class=p>}</span>
<span class=n>BinaryTree</span><span class=p>.</span><span class=n>__index</span> <span class=o>=</span> <span class=n>BinaryTree</span>

<span class=c1>---Creates new Binary Tree</span>
<span class=c1>---@return BinaryTree</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>new</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>t</span> <span class=o>=</span> <span class=p>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=kc>nil</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=kr>return</span> <span class=nb>setmetatable</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>self</span><span class=p>)</span>
<span class=kr>end</span>

<span class=c1>---Pre-order DFS: Root, Left, Right</span>
<span class=c1>---@param node Node | nil</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>preOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
        <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
<span class=kr>end</span>

<span class=c1>---Post-order DFS: Left, Right, Root</span>
<span class=c1>---@param node Node | nil</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>postOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>postOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>postOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
        <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=kr>end</span>
<span class=kr>end</span>

<span class=c1>---In-order DFS: Left, Root, Right</span>
<span class=c1>---@param node Node</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>inOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>inOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
        <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=kr>end</span>
    <span class=n>self</span><span class=p>:</span><span class=n>inOrderDFS</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span><span class=n>T</span>
<span class=kr>end</span>

<span class=c1>---BFS: Level order traversal</span>
<span class=c1>---@param callback BinaryTreeCallback</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>BFS</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span>
    <span class=kr>end</span>
    <span class=kd>local</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>
        <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
            <span class=n>callback</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
<span class=kr>end</span>

<span class=c1>---Checks that value has a node</span>
<span class=c1>---@param node Node | nil</span>
<span class=c1>---@param needle any</span>
<span class=c1>---@param predicate BinaryTreePredicate</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>contains</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>needle</span><span class=p>,</span> <span class=n>predicate</span><span class=p>)</span>
    <span class=c1>-- Base case: If the tree is empty or we've reached</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=kc>false</span>
    <span class=kr>end</span>

    <span class=c1>-- If the node's data is equal to the value we are</span>
    <span class=c1>-- searching for</span>
    <span class=kr>if</span> <span class=n>predicate</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>needle</span><span class=p>)</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=kc>true</span>
    <span class=kr>end</span>

    <span class=c1>-- Recursively search in the left and right subtrees</span>
    <span class=kd>local</span> <span class=n>leftFound</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>contains</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>needle</span><span class=p>,</span> <span class=n>predicate</span><span class=p>)</span>
    <span class=kd>local</span> <span class=n>rightFound</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>contains</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>needle</span><span class=p>,</span> <span class=n>predicate</span><span class=p>)</span>

    <span class=kr>return</span> <span class=n>leftFound</span> <span class=ow>or</span> <span class=n>rightFound</span>
<span class=kr>end</span>

<span class=c1>---Inserts new element to the binary tree.</span>
<span class=c1>---@param data any</span>
<span class=c1>---@return Node</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>insert</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=kr>return</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>end</span>
    <span class=kd>local</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>

        <span class=kr>if</span> <span class=n>temp</span><span class=p>.</span><span class=n>left</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>temp</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
            <span class=kr>break</span>
        <span class=kr>else</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>temp</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>end</span>

        <span class=kr>if</span> <span class=n>temp</span><span class=p>.</span><span class=n>right</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>temp</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
            <span class=kr>break</span>
        <span class=kr>else</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>temp</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=n>root</span>
<span class=kr>end</span>

<span class=c1>---Deletes an element from the binary tree.</span>
<span class=c1>---@param data any</span>
<span class=c1>---@return Node | nil</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>delete</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=kc>nil</span>
    <span class=kr>end</span>
    <span class=kd>local</span> <span class=n>target</span>
    <span class=kd>local</span> <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>currNode</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>

        <span class=kr>if</span> <span class=n>currNode</span><span class=p>.</span><span class=n>data</span> <span class=o>==</span> <span class=n>data</span> <span class=kr>then</span>
            <span class=n>target</span> <span class=o>=</span> <span class=n>currNode</span>
            <span class=kr>break</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>currNode</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currNode</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>currNode</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currNode</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
    <span class=kr>if</span> <span class=n>target</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>end</span>

    <span class=c1>-- Find the deepest rightmost node and its parent</span>
    <span class=kd>local</span> <span class=n>lastNode</span><span class=p>,</span> <span class=n>lastParent</span>
    <span class=n>queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>parentQueue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>
    <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>)</span>

    <span class=kr>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=p>:</span><span class=n>isEmpty</span><span class=p>()</span> <span class=kr>do</span>
        <span class=kd>local</span> <span class=n>currentNode</span> <span class=o>=</span> <span class=n>queue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>
        <span class=kd>local</span> <span class=n>parentNode</span> <span class=o>=</span> <span class=n>parentQueue</span><span class=p>:</span><span class=n>dequeue</span><span class=p>()</span>
        <span class=n>lastNode</span> <span class=o>=</span> <span class=n>currentNode</span>
        <span class=n>lastParent</span> <span class=o>=</span> <span class=n>parentNode</span>

        <span class=kr>if</span> <span class=n>currentNode</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
            <span class=n>parentQueue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=kr>if</span> <span class=n>currentNode</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
            <span class=n>queue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
            <span class=n>parentQueue</span><span class=p>:</span><span class=n>enqueue</span><span class=p>(</span><span class=n>currentNode</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>

    <span class=c1>-- Replace target's value with the last node's value</span>
    <span class=n>target</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>lastNode</span><span class=p>.</span><span class=n>data</span>

    <span class=c1>-- Remove the last node</span>
    <span class=kr>if</span> <span class=n>lastParent</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>if</span> <span class=n>lastParent</span><span class=p>.</span><span class=n>left</span> <span class=o>==</span> <span class=n>lastNode</span> <span class=kr>then</span>
            <span class=n>lastParent</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>nil</span>
        <span class=kr>else</span>
            <span class=n>lastParent</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>nil</span>
        <span class=kr>end</span>
    <span class=kr>else</span>
        <span class=kr>return</span> <span class=kc>nil</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
<span class=kr>end</span>

<span class=c1>---Gets the number of nodes in BinaryTree.</span>
<span class=c1>---@return number</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>size</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>self</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>_</span><span class=p>)</span>
        <span class=n>n</span> <span class=o>=</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span>
    <span class=kr>end</span><span class=p>)</span>
    <span class=kr>return</span> <span class=n>n</span>
<span class=kr>end</span>

<span class=c1>---@param node Node | nil</span>
<span class=c1>---@return number</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>getHeight</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=n>node</span> <span class=o>=</span> <span class=n>node</span> <span class=ow>or</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>end</span>

    <span class=kd>local</span> <span class=n>leftHeight</span> <span class=o>=</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=ow>and</span> <span class=n>self</span><span class=p>:</span><span class=n>getHeight</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>)</span> <span class=ow>or</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kd>local</span> <span class=n>rightHeight</span> <span class=o>=</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=ow>and</span> <span class=n>self</span><span class=p>:</span><span class=n>getHeight</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>)</span> <span class=ow>or</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>return</span> <span class=nb>math.max</span><span class=p>(</span><span class=n>leftHeight</span><span class=p>,</span> <span class=n>rightHeight</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
<span class=kr>end</span>

<span class=c1>---Gets the depth of the given node. 0 is for the root node, -1 if the Binary Tree is empty.</span>
<span class=c1>---@param target any</span>
<span class=c1>---@param level? number</span>
<span class=c1>---@param node? Node | nil</span>
<span class=c1>---@return number</span>
<span class=kr>function</span> <span class=nc>BinaryTree</span><span class=p>:</span><span class=nf>getLevel</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>node</span><span class=p>)</span>
    <span class=n>level</span> <span class=o>=</span> <span class=n>level</span> <span class=ow>or</span> <span class=mi>0</span>
    <span class=n>node</span> <span class=o>=</span> <span class=n>node</span> <span class=ow>or</span> <span class=n>self</span><span class=p>.</span><span class=n>root</span>
    <span class=kr>if</span> <span class=n>node</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>end</span>

    <span class=kr>if</span> <span class=n>target</span> <span class=o>==</span> <span class=n>node</span><span class=p>.</span><span class=n>data</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=n>level</span>
    <span class=kr>end</span>

    <span class=kd>local</span> <span class=n>leftLevel</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
    <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=n>leftLevel</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>node</span><span class=p>.</span><span class=n>left</span><span class=p>)</span>
        <span class=kr>if</span> <span class=n>leftLevel</span> <span class=o>~=</span> <span class=o>-</span><span class=mi>1</span> <span class=kr>then</span>
            <span class=kr>return</span> <span class=n>leftLevel</span>
        <span class=kr>end</span>
    <span class=kr>end</span>

    <span class=kr>if</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span> <span class=o>~=</span> <span class=kc>nil</span> <span class=kr>then</span>
        <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>node</span><span class=p>.</span><span class=n>right</span><span class=p>)</span>
    <span class=kr>end</span>
    <span class=kr>return</span> <span class=o>-</span><span class=mi>1</span>
<span class=kr>end</span>

<span class=kr>return</span> <span class=n>BinaryTree</span>
</code></pre></div><h3 id=usage-of-binarytree-class>Usage of BinaryTree class<a title="Permanent link" class=headerlink href=#usage-of-binarytree-class>#</a></h3><div class=codehilite><pre><span></span><code><span class=c1>-- Create a new binary tree instance</span>
<span class=kd>local</span> <span class=n>btree</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>:</span><span class=n>new</span><span class=p>()</span>

<span class=c1>-- Creating nodes</span>
<span class=kd>local</span> <span class=n>a</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"A"</span><span class=p>)</span> <span class=c1>-- root</span>
<span class=kd>local</span> <span class=n>b</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"B"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>c</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"C"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>d</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"D"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>e</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"E"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>f</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"F"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>g</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"G"</span><span class=p>)</span>
<span class=kd>local</span> <span class=n>h</span> <span class=o>=</span> <span class=n>BinaryTree</span><span class=p>.</span><span class=n>createNode</span><span class=p>(</span><span class=s2>"H"</span><span class=p>)</span>

<span class=c1>-- Make relation between root and nodes</span>
<span class=n>btree</span><span class=p>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>a</span>
<span class=n>a</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>b</span>
<span class=n>a</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>c</span>
<span class=n>b</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>d</span>
<span class=n>b</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>e</span>
<span class=n>e</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>g</span>
<span class=n>e</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>h</span>
<span class=n>c</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>f</span>

<span class=n>btree</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>btree</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=nb>io.write</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=s2>" -> "</span><span class=p>)</span>
<span class=kr>end</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=c1>-- A -> B -> D -> E -> G -> H -> C -> F -> nil</span>

<span class=n>btree</span><span class=p>:</span><span class=n>postOrderDFS</span><span class=p>(</span><span class=n>btree</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=nb>io.write</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=s2>" -> "</span><span class=p>)</span>
<span class=kr>end</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=c1>-- D -> G -> H -> E -> B -> F -> C -> A -> nil</span>

<span class=n>btree</span><span class=p>:</span><span class=n>inOrderDFS</span><span class=p>(</span><span class=n>btree</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=nb>io.write</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=s2>" -> "</span><span class=p>)</span>
<span class=kr>end</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=c1>-- D -> B -> G -> E -> H -> A -> F -> C -> nil</span>

<span class=n>btree</span><span class=p>:</span><span class=n>BFS</span><span class=p>(</span><span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=nb>io.write</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=s2>" -> "</span><span class=p>)</span>
<span class=kr>end</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=c1>-- A -> B -> C -> D -> E -> F -> G -> H -> nil</span>

<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>contains</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>"F"</span><span class=p>,</span> <span class=n>compare</span><span class=p>),</span> <span class=n>btree</span><span class=p>:</span><span class=n>contains</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>"J"</span><span class=p>,</span> <span class=n>compare</span><span class=p>))</span>

<span class=n>btree</span><span class=p>:</span><span class=n>insert</span><span class=p>(</span><span class=s2>"I"</span><span class=p>)</span>
<span class=n>btree</span><span class=p>:</span><span class=n>insert</span><span class=p>(</span><span class=s2>"J"</span><span class=p>)</span>
<span class=n>btree</span><span class=p>:</span><span class=n>insert</span><span class=p>(</span><span class=s2>"K"</span><span class=p>)</span>
<span class=n>btree</span><span class=p>:</span><span class=n>insert</span><span class=p>(</span><span class=s2>"L"</span><span class=p>)</span>
<span class=n>btree</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>btree</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=nb>io.write</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=s2>" -> "</span><span class=p>)</span>
<span class=kr>end</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=c1>--A -> B -> D -> J -> K -> E -> G -> H -> C -> F -> L -> I -> nil</span>

<span class=n>btree</span><span class=p>:</span><span class=n>delete</span><span class=p>(</span><span class=s2>"C"</span><span class=p>)</span>
<span class=n>btree</span><span class=p>:</span><span class=n>delete</span><span class=p>(</span><span class=s2>"E"</span><span class=p>)</span>
<span class=n>btree</span><span class=p>:</span><span class=n>preOrderDFS</span><span class=p>(</span><span class=n>btree</span><span class=p>.</span><span class=n>root</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
    <span class=nb>io.write</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> <span class=s2>" -> "</span><span class=p>)</span>
<span class=kr>end</span><span class=p>)</span>
<span class=nb>print</span><span class=p>()</span>
<span class=c1>-- A -> B -> D -> J -> K -> H -> G -> L -> F -> I -></span>

<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>size</span><span class=p>())</span> <span class=c1>--> 10</span>
<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>getHeight</span><span class=p>())</span> <span class=c1>--> 3</span>
<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=s2>"A"</span><span class=p>))</span> <span class=c1>--> 0</span>
<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=s2>"B"</span><span class=p>))</span> <span class=c1>--> 1</span>
<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=s2>"D"</span><span class=p>))</span> <span class=c1>--> 2</span>
<span class=nb>print</span><span class=p>(</span><span class=n>btree</span><span class=p>:</span><span class=n>getLevel</span><span class=p>(</span><span class=s2>"G"</span><span class=p>))</span> <span class=c1>--> 3</span>
</code></pre></div><h2>Feedback</h2><p>For feedback, please check the <a href=/me/>contacts</a> section. Before writing, please specify where you came from and who you are. Sometimes spammers go insane. Thank you in advance for your understanding.</article><a href=/>← Back to the index page</a></main><footer><hr><p>(c) 2022-2025 <a href=/me/>xdknight</a> Powered by <a href=https://github.com/hmngwy/jenny>Jenny</a> shell blog engine.<p>Any images on this website may be used, copied and redistributed under the <a href=https://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a> license.<p>Any code on this website may be used, copied and redistributed under the <a href=https://opensource.org/license/MIT>MIT</a> license.<p>This website does not use cookies or any tracking techniques either. Also, this page is fully accessible, responsive, and readable on any device without a single line of JavaScript.</footer>